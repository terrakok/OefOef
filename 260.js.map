{"version":3,"file":"260.js","mappings":"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","sources":["webpack://webApp/../../node_modules/nspell/lib/util/rule-codes.js","webpack://webApp/../../node_modules/nspell/lib/word-characters.js","webpack://webApp/../../node_modules/nspell/lib/util/affix.js","webpack://webApp/../../node_modules/nspell/lib/spell.js","webpack://webApp/../../node_modules/nspell/lib/util/apply.js","webpack://webApp/../../node_modules/nspell/lib/util/casing.js","webpack://webApp/../../node_modules/nspell/lib/index.js","webpack://webApp/../../node_modules/nspell/lib/util/flag.js","webpack://webApp/../../node_modules/is-buffer/index.js","webpack://webApp/../../node_modules/nspell/lib/suggest.js","webpack://webApp/../../node_modules/nspell/lib/correct.js","webpack://webApp/../../node_modules/nspell/lib/util/add.js","webpack://webApp/../../node_modules/nspell/lib/util/normalize.js","webpack://webApp/../../node_modules/nspell/lib/add.js","webpack://webApp/../../node_modules/nspell/lib/personal.js","webpack://webApp/../../node_modules/nspell/lib/dictionary.js","webpack://webApp/../../node_modules/nspell/lib/remove.js","webpack://webApp/../../node_modules/nspell/lib/util/exact.js","webpack://webApp/../../node_modules/nspell/lib/util/form.js","webpack://webApp/../../node_modules/nspell/lib/util/dictionary.js"],"sourcesContent":["'use strict'\n\nmodule.exports = ruleCodes\n\nvar NO_CODES = []\n\n// Parse rule codes.\nfunction ruleCodes(flags, value) {\n  var index = 0\n  var result\n\n  if (!value) return NO_CODES\n\n  if (flags.FLAG === 'long') {\n    // Creating an array of the right length immediately\n    // avoiding resizes and using memory more efficiently\n    result = new Array(Math.ceil(value.length / 2))\n\n    while (index < value.length) {\n      result[index / 2] = value.slice(index, index + 2)\n      index += 2\n    }\n\n    return result\n  }\n\n  return value.split(flags.FLAG === 'num' ? ',' : '')\n}\n","'use strict'\n\nmodule.exports = wordCharacters\n\n// Get the word characters defined in affix.\nfunction wordCharacters() {\n  return this.flags.WORDCHARS || null\n}\n","'use strict'\n\nvar parse = require('./rule-codes.js')\n\nmodule.exports = affix\n\nvar push = [].push\n\n// Relative frequencies of letters in the English language.\nvar alphabet = 'etaoinshrdlcumwfgypbvkjxqz'.split('')\n\n// Expressions.\nvar whiteSpaceExpression = /\\s+/\n\n// Defaults.\nvar defaultKeyboardLayout = [\n  'qwertzuop',\n  'yxcvbnm',\n  'qaw',\n  'say',\n  'wse',\n  'dsx',\n  'sy',\n  'edr',\n  'fdc',\n  'dx',\n  'rft',\n  'gfv',\n  'fc',\n  'tgz',\n  'hgb',\n  'gv',\n  'zhu',\n  'jhn',\n  'hb',\n  'uji',\n  'kjm',\n  'jn',\n  'iko',\n  'lkm'\n]\n\n// Parse an affix file.\n// eslint-disable-next-line complexity\nfunction affix(doc) {\n  var rules = Object.create(null)\n  var compoundRuleCodes = Object.create(null)\n  var flags = Object.create(null)\n  var replacementTable = []\n  var conversion = {in: [], out: []}\n  var compoundRules = []\n  var aff = doc.toString('utf8')\n  var lines = []\n  var last = 0\n  var index = aff.indexOf('\\n')\n  var parts\n  var line\n  var ruleType\n  var count\n  var remove\n  var add\n  var source\n  var entry\n  var position\n  var rule\n  var value\n  var offset\n  var character\n\n  flags.KEY = []\n\n  // Process the affix buffer into a list of applicable lines.\n  while (index > -1) {\n    pushLine(aff.slice(last, index))\n    last = index + 1\n    index = aff.indexOf('\\n', last)\n  }\n\n  pushLine(aff.slice(last))\n\n  // Process each line.\n  index = -1\n\n  while (++index < lines.length) {\n    line = lines[index]\n    parts = line.split(whiteSpaceExpression)\n    ruleType = parts[0]\n\n    if (ruleType === 'REP') {\n      count = index + parseInt(parts[1], 10)\n\n      while (++index <= count) {\n        parts = lines[index].split(whiteSpaceExpression)\n        replacementTable.push([parts[1], parts[2]])\n      }\n\n      index--\n    } else if (ruleType === 'ICONV' || ruleType === 'OCONV') {\n      count = index + parseInt(parts[1], 10)\n      entry = conversion[ruleType === 'ICONV' ? 'in' : 'out']\n\n      while (++index <= count) {\n        parts = lines[index].split(whiteSpaceExpression)\n        entry.push([new RegExp(parts[1], 'g'), parts[2]])\n      }\n\n      index--\n    } else if (ruleType === 'COMPOUNDRULE') {\n      count = index + parseInt(parts[1], 10)\n\n      while (++index <= count) {\n        rule = lines[index].split(whiteSpaceExpression)[1]\n        position = -1\n\n        compoundRules.push(rule)\n\n        while (++position < rule.length) {\n          compoundRuleCodes[rule.charAt(position)] = []\n        }\n      }\n\n      index--\n    } else if (ruleType === 'PFX' || ruleType === 'SFX') {\n      count = index + parseInt(parts[3], 10)\n\n      rule = {\n        type: ruleType,\n        combineable: parts[2] === 'Y',\n        entries: []\n      }\n\n      rules[parts[1]] = rule\n\n      while (++index <= count) {\n        parts = lines[index].split(whiteSpaceExpression)\n        remove = parts[2]\n        add = parts[3].split('/')\n        source = parts[4]\n\n        entry = {\n          add: '',\n          remove: '',\n          match: '',\n          continuation: parse(flags, add[1])\n        }\n\n        if (add && add[0] !== '0') {\n          entry.add = add[0]\n        }\n\n        try {\n          if (remove !== '0') {\n            entry.remove = ruleType === 'SFX' ? end(remove) : remove\n          }\n\n          if (source && source !== '.') {\n            entry.match = ruleType === 'SFX' ? end(source) : start(source)\n          }\n        } catch (_) {\n          // Ignore invalid regex patterns.\n          entry = null\n        }\n\n        if (entry) {\n          rule.entries.push(entry)\n        }\n      }\n\n      index--\n    } else if (ruleType === 'TRY') {\n      source = parts[1]\n      offset = -1\n      value = []\n\n      while (++offset < source.length) {\n        character = source.charAt(offset)\n\n        if (character.toLowerCase() === character) {\n          value.push(character)\n        }\n      }\n\n      // Some dictionaries may forget a character.\n      // Notably `en` forgets `j`, `x`, and `y`.\n      offset = -1\n\n      while (++offset < alphabet.length) {\n        if (source.indexOf(alphabet[offset]) < 0) {\n          value.push(alphabet[offset])\n        }\n      }\n\n      flags[ruleType] = value\n    } else if (ruleType === 'KEY') {\n      push.apply(flags[ruleType], parts[1].split('|'))\n    } else if (ruleType === 'COMPOUNDMIN') {\n      flags[ruleType] = Number(parts[1])\n    } else if (ruleType === 'ONLYINCOMPOUND') {\n      // If we add this ONLYINCOMPOUND flag to `compoundRuleCodes`, then\n      // `parseDic` will do the work of saving the list of words that are\n      // compound-only.\n      flags[ruleType] = parts[1]\n      compoundRuleCodes[parts[1]] = []\n    } else if (\n      ruleType === 'FLAG' ||\n      ruleType === 'KEEPCASE' ||\n      ruleType === 'NOSUGGEST' ||\n      ruleType === 'WORDCHARS'\n    ) {\n      flags[ruleType] = parts[1]\n    } else {\n      // Default handling: set them for now.\n      flags[ruleType] = parts[1]\n    }\n  }\n\n  // Default for `COMPOUNDMIN` is `3`.\n  // See `man 4 hunspell`.\n  if (isNaN(flags.COMPOUNDMIN)) {\n    flags.COMPOUNDMIN = 3\n  }\n\n  if (!flags.KEY.length) {\n    flags.KEY = defaultKeyboardLayout\n  }\n\n  /* istanbul ignore if - Dictionaries seem to always have this. */\n  if (!flags.TRY) {\n    flags.TRY = alphabet.concat()\n  }\n\n  if (!flags.KEEPCASE) {\n    flags.KEEPCASE = false\n  }\n\n  return {\n    compoundRuleCodes: compoundRuleCodes,\n    replacementTable: replacementTable,\n    conversion: conversion,\n    compoundRules: compoundRules,\n    rules: rules,\n    flags: flags\n  }\n\n  function pushLine(line) {\n    line = line.trim()\n\n    // Hash can be a valid flag, so we only discard line that starts with it.\n    if (line && line.charCodeAt(0) !== 35 /* `#` */) {\n      lines.push(line)\n    }\n  }\n}\n\n// Wrap the `source` of an expression-like string so that it matches only at\n// the end of a value.\nfunction end(source) {\n  return new RegExp(source + '$')\n}\n\n// Wrap the `source` of an expression-like string so that it matches only at\n// the start of a value.\nfunction start(source) {\n  return new RegExp('^' + source)\n}\n","'use strict'\n\nvar form = require('./util/form.js')\nvar flag = require('./util/flag.js')\n\nmodule.exports = spell\n\n// Check spelling of `word`.\nfunction spell(word) {\n  var self = this\n  var value = form(self, word, true)\n\n  // Hunspell also provides `root` (root word of the input word), and `compound`\n  // (whether `word` was compound).\n  return {\n    correct: self.correct(word),\n    forbidden: Boolean(\n      value && flag(self.flags, 'FORBIDDENWORD', self.data[value])\n    ),\n    warn: Boolean(value && flag(self.flags, 'WARN', self.data[value]))\n  }\n}\n","'use strict'\n\nmodule.exports = apply\n\n// Apply a rule.\nfunction apply(value, rule, rules, words) {\n  var index = -1\n  var entry\n  var next\n  var continuationRule\n  var continuation\n  var position\n\n  while (++index < rule.entries.length) {\n    entry = rule.entries[index]\n    continuation = entry.continuation\n    position = -1\n\n    if (!entry.match || entry.match.test(value)) {\n      next = entry.remove ? value.replace(entry.remove, '') : value\n      next = rule.type === 'SFX' ? next + entry.add : entry.add + next\n      words.push(next)\n\n      if (continuation && continuation.length) {\n        while (++position < continuation.length) {\n          continuationRule = rules[continuation[position]]\n\n          if (continuationRule) {\n            apply(next, continuationRule, rules, words)\n          }\n        }\n      }\n    }\n  }\n\n  return words\n}\n","'use strict'\n\nmodule.exports = casing\n\n// Get the casing of `value`.\nfunction casing(value) {\n  var head = exact(value.charAt(0))\n  var rest = value.slice(1)\n\n  if (!rest) {\n    return head\n  }\n\n  rest = exact(rest)\n\n  if (head === rest) {\n    return head\n  }\n\n  if (head === 'u' && rest === 'l') {\n    return 's'\n  }\n\n  return null\n}\n\nfunction exact(value) {\n  return value === value.toLowerCase()\n    ? 'l'\n    : value === value.toUpperCase()\n    ? 'u'\n    : null\n}\n","'use strict'\n\nvar buffer = require('is-buffer')\nvar affix = require('./util/affix.js')\n\nmodule.exports = NSpell\n\nvar proto = NSpell.prototype\n\nproto.correct = require('./correct.js')\nproto.suggest = require('./suggest.js')\nproto.spell = require('./spell.js')\nproto.add = require('./add.js')\nproto.remove = require('./remove.js')\nproto.wordCharacters = require('./word-characters.js')\nproto.dictionary = require('./dictionary.js')\nproto.personal = require('./personal.js')\n\n// Construct a new spelling context.\nfunction NSpell(aff, dic) {\n  var index = -1\n  var dictionaries\n\n  if (!(this instanceof NSpell)) {\n    return new NSpell(aff, dic)\n  }\n\n  if (typeof aff === 'string' || buffer(aff)) {\n    if (typeof dic === 'string' || buffer(dic)) {\n      dictionaries = [{dic: dic}]\n    }\n  } else if (aff) {\n    if ('length' in aff) {\n      dictionaries = aff\n      aff = aff[0] && aff[0].aff\n    } else {\n      if (aff.dic) {\n        dictionaries = [aff]\n      }\n\n      aff = aff.aff\n    }\n  }\n\n  if (!aff) {\n    throw new Error('Missing `aff` in dictionary')\n  }\n\n  aff = affix(aff)\n\n  this.data = Object.create(null)\n  this.compoundRuleCodes = aff.compoundRuleCodes\n  this.replacementTable = aff.replacementTable\n  this.conversion = aff.conversion\n  this.compoundRules = aff.compoundRules\n  this.rules = aff.rules\n  this.flags = aff.flags\n\n  if (dictionaries) {\n    while (++index < dictionaries.length) {\n      if (dictionaries[index].dic) {\n        this.dictionary(dictionaries[index].dic)\n      }\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = flag\n\n// Check whether a word has a flag.\nfunction flag(values, value, flags) {\n  return flags && value in values && flags.indexOf(values[value]) > -1\n}\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","'use strict'\n\nvar casing = require('./util/casing.js')\nvar normalize = require('./util/normalize.js')\nvar flag = require('./util/flag.js')\nvar form = require('./util/form.js')\n\nmodule.exports = suggest\n\nvar push = [].push\n\n// Suggest spelling for `value`.\n// eslint-disable-next-line complexity\nfunction suggest(value) {\n  var self = this\n  var charAdded = {}\n  var suggestions = []\n  var weighted = {}\n  var memory\n  var replacement\n  var edits = []\n  var values\n  var index\n  var offset\n  var position\n  var count\n  var otherOffset\n  var otherCharacter\n  var character\n  var group\n  var before\n  var after\n  var upper\n  var insensitive\n  var firstLevel\n  var previous\n  var next\n  var nextCharacter\n  var max\n  var distance\n  var size\n  var normalized\n  var suggestion\n  var currentCase\n\n  value = normalize(value.trim(), self.conversion.in)\n\n  if (!value || self.correct(value)) {\n    return []\n  }\n\n  currentCase = casing(value)\n\n  // Check the replacement table.\n  index = -1\n\n  while (++index < self.replacementTable.length) {\n    replacement = self.replacementTable[index]\n    offset = value.indexOf(replacement[0])\n\n    while (offset > -1) {\n      edits.push(value.replace(replacement[0], replacement[1]))\n      offset = value.indexOf(replacement[0], offset + 1)\n    }\n  }\n\n  // Check the keyboard.\n  index = -1\n\n  while (++index < value.length) {\n    character = value.charAt(index)\n    before = value.slice(0, index)\n    after = value.slice(index + 1)\n    insensitive = character.toLowerCase()\n    upper = insensitive !== character\n    charAdded = {}\n\n    offset = -1\n\n    while (++offset < self.flags.KEY.length) {\n      group = self.flags.KEY[offset]\n      position = group.indexOf(insensitive)\n\n      if (position < 0) {\n        continue\n      }\n\n      otherOffset = -1\n\n      while (++otherOffset < group.length) {\n        if (otherOffset !== position) {\n          otherCharacter = group.charAt(otherOffset)\n\n          if (charAdded[otherCharacter]) {\n            continue\n          }\n\n          charAdded[otherCharacter] = true\n\n          if (upper) {\n            otherCharacter = otherCharacter.toUpperCase()\n          }\n\n          edits.push(before + otherCharacter + after)\n        }\n      }\n    }\n  }\n\n  // Check cases where one of a double character was forgotten, or one too many\n  // were added, up to three “distances”.  This increases the success-rate by 2%\n  // and speeds the process up by 13%.\n  index = -1\n  nextCharacter = value.charAt(0)\n  values = ['']\n  max = 1\n  distance = 0\n\n  while (++index < value.length) {\n    character = nextCharacter\n    nextCharacter = value.charAt(index + 1)\n    before = value.slice(0, index)\n\n    replacement = character === nextCharacter ? '' : character + character\n    offset = -1\n    count = values.length\n\n    while (++offset < count) {\n      if (offset <= max) {\n        values.push(values[offset] + replacement)\n      }\n\n      values[offset] += character\n    }\n\n    if (++distance < 3) {\n      max = values.length\n    }\n  }\n\n  push.apply(edits, values)\n\n  // Ensure the capitalised and uppercase values are included.\n  values = [value]\n  replacement = value.toLowerCase()\n\n  if (value === replacement || currentCase === null) {\n    values.push(value.charAt(0).toUpperCase() + replacement.slice(1))\n  }\n\n  replacement = value.toUpperCase()\n\n  if (value !== replacement) {\n    values.push(replacement)\n  }\n\n  // Construct a memory object for `generate`.\n  memory = {\n    state: {},\n    weighted: weighted,\n    suggestions: suggestions\n  }\n\n  firstLevel = generate(self, memory, values, edits)\n\n  // While there are no suggestions based on generated values with an\n  // edit-distance of `1`, check the generated values, `SIZE` at a time.\n  // Basically, we’re generating values with an edit-distance of `2`, but were\n  // doing it in small batches because it’s such an expensive operation.\n  previous = 0\n  max = Math.min(firstLevel.length, Math.pow(Math.max(15 - value.length, 3), 3))\n  size = Math.max(Math.pow(10 - value.length, 3), 1)\n\n  while (!suggestions.length && previous < max) {\n    next = previous + size\n    generate(self, memory, firstLevel.slice(previous, next))\n    previous = next\n  }\n\n  // Sort the suggestions based on their weight.\n  suggestions.sort(sort)\n\n  // Normalize the output.\n  values = []\n  normalized = []\n  index = -1\n\n  while (++index < suggestions.length) {\n    suggestion = normalize(suggestions[index], self.conversion.out)\n    replacement = suggestion.toLowerCase()\n\n    if (normalized.indexOf(replacement) < 0) {\n      values.push(suggestion)\n      normalized.push(replacement)\n    }\n  }\n\n  // BOOM! All done!\n  return values\n\n  function sort(a, b) {\n    return sortWeight(a, b) || sortCasing(a, b) || sortAlpha(a, b)\n  }\n\n  function sortWeight(a, b) {\n    return weighted[a] === weighted[b] ? 0 : weighted[a] > weighted[b] ? -1 : 1\n  }\n\n  function sortCasing(a, b) {\n    var leftCasing = casing(a)\n    var rightCasing = casing(b)\n\n    return leftCasing === rightCasing\n      ? 0\n      : leftCasing === currentCase\n      ? -1\n      : rightCasing === currentCase\n      ? 1\n      : undefined\n  }\n\n  function sortAlpha(a, b) {\n    return a.localeCompare(b)\n  }\n}\n\n// Get a list of values close in edit distance to `words`.\nfunction generate(context, memory, words, edits) {\n  var characters = context.flags.TRY\n  var data = context.data\n  var flags = context.flags\n  var result = []\n  var index = -1\n  var word\n  var before\n  var character\n  var nextCharacter\n  var nextAfter\n  var nextNextAfter\n  var nextUpper\n  var currentCase\n  var position\n  var after\n  var upper\n  var inject\n  var offset\n\n  // Check the pre-generated edits.\n  if (edits) {\n    while (++index < edits.length) {\n      check(edits[index], true)\n    }\n  }\n\n  // Iterate over given word.\n  index = -1\n\n  while (++index < words.length) {\n    word = words[index]\n    before = ''\n    character = ''\n    nextCharacter = word.charAt(0)\n    nextAfter = word\n    nextNextAfter = word.slice(1)\n    nextUpper = nextCharacter.toLowerCase() !== nextCharacter\n    currentCase = casing(word)\n    position = -1\n\n    // Iterate over every character (including the end).\n    while (++position <= word.length) {\n      before += character\n      after = nextAfter\n      nextAfter = nextNextAfter\n      nextNextAfter = nextAfter.slice(1)\n      character = nextCharacter\n      nextCharacter = word.charAt(position + 1)\n      upper = nextUpper\n\n      if (nextCharacter) {\n        nextUpper = nextCharacter.toLowerCase() !== nextCharacter\n      }\n\n      if (nextAfter && upper !== nextUpper) {\n        // Remove.\n        check(before + switchCase(nextAfter))\n\n        // Switch.\n        check(\n          before +\n            switchCase(nextCharacter) +\n            switchCase(character) +\n            nextNextAfter\n        )\n      }\n\n      // Remove.\n      check(before + nextAfter)\n\n      // Switch.\n      if (nextAfter) {\n        check(before + nextCharacter + character + nextNextAfter)\n      }\n\n      // Iterate over all possible letters.\n      offset = -1\n\n      while (++offset < characters.length) {\n        inject = characters[offset]\n\n        // Try uppercase if the original character was uppercased.\n        if (upper && inject !== inject.toUpperCase()) {\n          if (currentCase !== 's') {\n            check(before + inject + after)\n            check(before + inject + nextAfter)\n          }\n\n          inject = inject.toUpperCase()\n\n          check(before + inject + after)\n          check(before + inject + nextAfter)\n        } else {\n          // Add and replace.\n          check(before + inject + after)\n          check(before + inject + nextAfter)\n        }\n      }\n    }\n  }\n\n  // Return the list of generated words.\n  return result\n\n  // Check and handle a generated value.\n  function check(value, double) {\n    var state = memory.state[value]\n    var corrected\n\n    if (state !== Boolean(state)) {\n      result.push(value)\n\n      corrected = form(context, value)\n      state = corrected && !flag(flags, 'NOSUGGEST', data[corrected])\n\n      memory.state[value] = state\n\n      if (state) {\n        memory.weighted[value] = double ? 10 : 0\n        memory.suggestions.push(value)\n      }\n    }\n\n    if (state) {\n      memory.weighted[value]++\n    }\n  }\n\n  function switchCase(fragment) {\n    var first = fragment.charAt(0)\n\n    return (\n      (first.toLowerCase() === first\n        ? first.toUpperCase()\n        : first.toLowerCase()) + fragment.slice(1)\n    )\n  }\n}\n","'use strict'\n\nvar form = require('./util/form.js')\n\nmodule.exports = correct\n\n// Check spelling of `value`.\nfunction correct(value) {\n  return Boolean(form(this, value))\n}\n","'use strict'\n\nvar apply = require('./apply.js')\n\nmodule.exports = add\n\nvar push = [].push\n\nvar NO_RULES = []\n\n// Add `rules` for `word` to the table.\nfunction addRules(dict, word, rules) {\n  var curr = dict[word]\n\n  // Some dictionaries will list the same word multiple times with different\n  // rule sets.\n  if (word in dict) {\n    if (curr === NO_RULES) {\n      dict[word] = rules.concat()\n    } else {\n      push.apply(curr, rules)\n    }\n  } else {\n    dict[word] = rules.concat()\n  }\n}\n\nfunction add(dict, word, codes, options) {\n  var position = -1\n  var rule\n  var offset\n  var subposition\n  var suboffset\n  var combined\n  var newWords\n  var otherNewWords\n\n  // Compound words.\n  if (\n    !('NEEDAFFIX' in options.flags) ||\n    codes.indexOf(options.flags.NEEDAFFIX) < 0\n  ) {\n    addRules(dict, word, codes)\n  }\n\n  while (++position < codes.length) {\n    rule = options.rules[codes[position]]\n\n    if (codes[position] in options.compoundRuleCodes) {\n      options.compoundRuleCodes[codes[position]].push(word)\n    }\n\n    if (rule) {\n      newWords = apply(word, rule, options.rules, [])\n      offset = -1\n\n      while (++offset < newWords.length) {\n        if (!(newWords[offset] in dict)) {\n          dict[newWords[offset]] = NO_RULES\n        }\n\n        if (rule.combineable) {\n          subposition = position\n\n          while (++subposition < codes.length) {\n            combined = options.rules[codes[subposition]]\n\n            if (\n              combined &&\n              combined.combineable &&\n              rule.type !== combined.type\n            ) {\n              otherNewWords = apply(\n                newWords[offset],\n                combined,\n                options.rules,\n                []\n              )\n              suboffset = -1\n\n              while (++suboffset < otherNewWords.length) {\n                if (!(otherNewWords[suboffset] in dict)) {\n                  dict[otherNewWords[suboffset]] = NO_RULES\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = normalize\n\n// Normalize `value` with patterns.\nfunction normalize(value, patterns) {\n  var index = -1\n\n  while (++index < patterns.length) {\n    value = value.replace(patterns[index][0], patterns[index][1])\n  }\n\n  return value\n}\n","'use strict'\n\nvar push = require('./util/add.js')\n\nmodule.exports = add\n\nvar NO_CODES = []\n\n// Add `value` to the checker.\nfunction add(value, model) {\n  var self = this\n\n  push(self.data, value, self.data[model] || NO_CODES, self)\n\n  return self\n}\n","'use strict'\n\nmodule.exports = add\n\n// Add a dictionary.\nfunction add(buf) {\n  var self = this\n  var lines = buf.toString('utf8').split('\\n')\n  var index = -1\n  var line\n  var forbidden\n  var word\n  var flag\n\n  // Ensure there’s a key for `FORBIDDENWORD`: `false` cannot be set through an\n  // affix file so its safe to use as a magic constant.\n  if (self.flags.FORBIDDENWORD === undefined) self.flags.FORBIDDENWORD = false\n  flag = self.flags.FORBIDDENWORD\n\n  while (++index < lines.length) {\n    line = lines[index].trim()\n\n    if (!line) {\n      continue\n    }\n\n    line = line.split('/')\n    word = line[0]\n    forbidden = word.charAt(0) === '*'\n\n    if (forbidden) {\n      word = word.slice(1)\n    }\n\n    self.add(word, line[1])\n\n    if (forbidden) {\n      self.data[word].push(flag)\n    }\n  }\n\n  return self\n}\n","'use strict'\n\nvar parse = require('./util/dictionary.js')\n\nmodule.exports = add\n\n// Add a dictionary file.\nfunction add(buf) {\n  var self = this\n  var index = -1\n  var rule\n  var source\n  var character\n  var offset\n\n  parse(buf, self, self.data)\n\n  // Regenerate compound expressions.\n  while (++index < self.compoundRules.length) {\n    rule = self.compoundRules[index]\n    source = ''\n    offset = -1\n\n    while (++offset < rule.length) {\n      character = rule.charAt(offset)\n      source += self.compoundRuleCodes[character].length\n        ? '(?:' + self.compoundRuleCodes[character].join('|') + ')'\n        : character\n    }\n\n    self.compoundRules[index] = new RegExp(source, 'i')\n  }\n\n  return self\n}\n","'use strict'\n\nmodule.exports = remove\n\n// Remove `value` from the checker.\nfunction remove(value) {\n  var self = this\n\n  delete self.data[value]\n\n  return self\n}\n","'use strict'\n\nvar flag = require('./flag.js')\n\nmodule.exports = exact\n\n// Check spelling of `value`, exactly.\nfunction exact(context, value) {\n  var index = -1\n\n  if (context.data[value]) {\n    return !flag(context.flags, 'ONLYINCOMPOUND', context.data[value])\n  }\n\n  // Check if this might be a compound word.\n  if (value.length >= context.flags.COMPOUNDMIN) {\n    while (++index < context.compoundRules.length) {\n      if (context.compoundRules[index].test(value)) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","'use strict'\n\nvar normalize = require('./normalize.js')\nvar exact = require('./exact.js')\nvar flag = require('./flag.js')\n\nmodule.exports = form\n\n// Find a known form of `value`.\nfunction form(context, value, all) {\n  var normal = value.trim()\n  var alternative\n\n  if (!normal) {\n    return null\n  }\n\n  normal = normalize(normal, context.conversion.in)\n\n  if (exact(context, normal)) {\n    if (!all && flag(context.flags, 'FORBIDDENWORD', context.data[normal])) {\n      return null\n    }\n\n    return normal\n  }\n\n  // Try sentence case if the value is uppercase.\n  if (normal.toUpperCase() === normal) {\n    alternative = normal.charAt(0) + normal.slice(1).toLowerCase()\n\n    if (ignore(context.flags, context.data[alternative], all)) {\n      return null\n    }\n\n    if (exact(context, alternative)) {\n      return alternative\n    }\n  }\n\n  // Try lowercase.\n  alternative = normal.toLowerCase()\n\n  if (alternative !== normal) {\n    if (ignore(context.flags, context.data[alternative], all)) {\n      return null\n    }\n\n    if (exact(context, alternative)) {\n      return alternative\n    }\n  }\n\n  return null\n}\n\nfunction ignore(flags, dict, all) {\n  return (\n    flag(flags, 'KEEPCASE', dict) || all || flag(flags, 'FORBIDDENWORD', dict)\n  )\n}\n","'use strict'\n\nvar parseCodes = require('./rule-codes.js')\nvar add = require('./add.js')\n\nmodule.exports = parse\n\n// Expressions.\nvar whiteSpaceExpression = /\\s/g\n\n// Parse a dictionary.\nfunction parse(buf, options, dict) {\n  // Parse as lines (ignoring the first line).\n  var value = buf.toString('utf8')\n  var last = value.indexOf('\\n') + 1\n  var index = value.indexOf('\\n', last)\n\n  while (index > -1) {\n    // Some dictionaries use tabs as comments.\n    if (value.charCodeAt(last) !== 9 /* `\\t` */) {\n      parseLine(value.slice(last, index), options, dict)\n    }\n\n    last = index + 1\n    index = value.indexOf('\\n', last)\n  }\n\n  parseLine(value.slice(last), options, dict)\n}\n\n// Parse a line in dictionary.\nfunction parseLine(line, options, dict) {\n  var slashOffset = line.indexOf('/')\n  var hashOffset = line.indexOf('#')\n  var codes = ''\n  var word\n  var result\n\n  // Find offsets.\n  while (\n    slashOffset > -1 &&\n    line.charCodeAt(slashOffset - 1) === 92 /* `\\` */\n  ) {\n    line = line.slice(0, slashOffset - 1) + line.slice(slashOffset)\n    slashOffset = line.indexOf('/', slashOffset)\n  }\n\n  // Handle hash and slash offsets.\n  // Note that hash can be a valid flag, so we should not just discard\n  // everything after it.\n  if (hashOffset > -1) {\n    if (slashOffset > -1 && slashOffset < hashOffset) {\n      word = line.slice(0, slashOffset)\n      whiteSpaceExpression.lastIndex = slashOffset + 1\n      result = whiteSpaceExpression.exec(line)\n      codes = line.slice(slashOffset + 1, result ? result.index : undefined)\n    } else {\n      word = line.slice(0, hashOffset)\n    }\n  } else if (slashOffset > -1) {\n    word = line.slice(0, slashOffset)\n    codes = line.slice(slashOffset + 1)\n  } else {\n    word = line\n  }\n\n  word = word.trim()\n\n  if (word) {\n    add(dict, word, parseCodes(options.flags, codes.trim()), options)\n  }\n}\n"],"names":["module","exports","flags","value","result","index","NO_CODES","FLAG","Array","Math","ceil","length","slice","split","this","WORDCHARS","parse","doc","parts","ruleType","count","remove","add","source","entry","position","rule","offset","character","rules","Object","create","compoundRuleCodes","replacementTable","conversion","in","out","compoundRules","aff","toString","lines","last","indexOf","KEY","pushLine","whiteSpaceExpression","parseInt","push","RegExp","charAt","type","combineable","entries","match","continuation","end","start","_","toLowerCase","alphabet","apply","Number","isNaN","COMPOUNDMIN","defaultKeyboardLayout","TRY","concat","KEEPCASE","line","trim","charCodeAt","form","flag","word","self","correct","forbidden","Boolean","data","warn","words","next","continuationRule","test","replace","exact","toUpperCase","head","rest","buffer","affix","NSpell","proto","prototype","dic","dictionaries","Error","dictionary","suggest","spell","wordCharacters","personal","values","obj","constructor","isBuffer","casing","normalize","memory","replacement","otherOffset","otherCharacter","group","before","after","upper","insensitive","firstLevel","previous","nextCharacter","max","distance","size","normalized","suggestion","currentCase","charAdded","suggestions","weighted","edits","generate","state","min","pow","sort","a","b","sortWeight","leftCasing","rightCasing","undefined","sortCasing","localeCompare","sortAlpha","context","nextAfter","nextNextAfter","nextUpper","inject","characters","check","switchCase","double","corrected","fragment","first","dict","codes","options","subposition","suboffset","combined","newWords","otherNewWords","NEEDAFFIX","curr","NO_RULES","addRules","patterns","model","buf","FORBIDDENWORD","join","ignore","all","alternative","normal","parseCodes","parseLine","slashOffset","hashOffset","lastIndex","exec"],"sourceRoot":""}